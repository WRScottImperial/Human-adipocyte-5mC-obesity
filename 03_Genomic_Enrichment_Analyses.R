#############################################################################################

##### Genomic Enrichment analyses of sentinel DNA methylation sites

#############################################################################################

### 1. Generation of 1000 permutations of unique CG sites equal in length to the number of sentinels, with equivalent mean (sd) methylation levels: 

# criteria i. difference in mean between sentinel and permutation; 
# criteria ii. difference in standard deviation (sd) between sentinel and permutation; 
# criteria iii. >5-kb distance between sentinel and permutation (i.e. not at the same genomic locus). 
# For each sentinel, difference in mean and sd is based on a sliding scale starting at mean 0.025 (i.e. 2.5%) and sd 0.0025 
# and increasing incrementally by mean 0.025 and sd 0.0025 until >1000 independent permuted CG sites are achieved.

# load sentinels

sentinels=read.csv(".../Obese_lean_SA_Combined_sentinels.csv")

# load mean (sd) methylation for each cpg site (quantified in obese and lean separately then combined).

load(".../mean_sd_methylation_SA_combined_groups.RData")
msd = anno[,c(52:53)]; colnames(msd)=c("meanMeth","sdMeth")

# generate a background table of all cgs, excluding sentinels and cgs within 5kb of a sentinel

hits=data.frame(msd[as.character(sentinels$CG),])
hits$CG=as.character(rownames(hits))
hits_anno = anno[anno$ID %in% hits$CG,]

for(c in 1:length(hits$CG)){
  
  print(c)
  cg = hits$CG[c]
  cg.coord = anno[cg,]
  cis.cg.coord = anno[anno$chr == cg.coord$chr & abs(anno$pos - cg.coord$pos)<5000,]
  if(cg==1) { cis.cgs = cis.cg.coord$ID }
  if(cg>1) { cis.cgs = c(cis.cgs,cis.cg.coord$ID) }
} 

cis.cgs=unique(cis.cgs)
backg=data.frame(msd[!(rownames(msd) %in% hits$CG),])
backg=data.frame(msd[!(rownames(msd) %in% cis.cgs),])

# set permutation parameters for sliding mean and standard deviation (starting low )

p1k = expand.grid(seq(0.0025, 0.025, 0.0025),seq(0.05,0.25,0.025),stringsAsFactors = FALSE); 
colnames(p1k)=c("SD","Mean")

# generate permutation set (nrows = number of sentinels, ncols =1000 )

matches = matrix(nrow=nrow(hits), ncol=1000)
colnames(matches) = as.character(seq(from =1 , to =1000, 1))
rownames(matches) = hits$CG
matchParameters = matrix(nrow=nrow(hits), ncol=3)
colnames(matchParameters)=c("mean_threshold","sd_threshold","n_matches")

dir="...permutations/sliding_mean_sd"

for(h in 1:nrow(hits)){
  
  cpg.match=NA
  len=NA
  hit=hits[h,]
  print(h)
  
  # calculate number of matches across range of mean sd thresholds
  
  for(para in 1:nrow(parameters)){
    n = length(sample(rownames(backg[abs(backg$meanMeth-hit$meanMeth)<parameters[para,2] & abs(backg$sdMeth-hit$sdMeth)<parameters[para,1],]))  )
    if(para==1) {sel = c(parameters[para,2],parameters[para,1],n)}
    if(para>1) {sel = rbind(sel,c(parameters[para,2],parameters[para,1],n))}
  }
  colnames(sel) = c("mean","sd","n_matches")
  
  # select mean sd thresholds n >1000 and use top (smallest) thresholds
  
  sel = sel[which(sel[,3]>nPerm),]
  meanthres = sel[1,1]
  sdthres = sel[1,2]
  nthresh = sel[1,3]
  
  # identify matches for each hit, filling by columns without replacement
  
  for(p in 1:nPerm){
    set.seed(p)
    print(p)
    if(exists('cgm')){rm(cgm)}
    cgms=sample(rownames(backg[abs(backg$meanMeth-hit$meanMeth)<meanthres & abs(backg$sdMeth-hit$sdMeth)<sdthres,])) 
    cgm=setdiff(cgms, cpg.match)[1]
    if(!is.na(cgm)){
      cpg.match=c(cpg.match,cgm)
    }else{
      cpg.match=c(cpg.match,(as.character(rownames(hit))))  # temporary solution
      print('no matching marker found')
    }
  }
  
  matches[h,]=na.omit(cpg.match)  
  matchParameters[h,] = c(meanthres,sdthres,nthresh)
  
}

save(matches,matchParameters, file=file.path(dir,"1000_permutations_SA_sentinels.RData"))


### 2. Enrichment analysis function: empirical

ENRICH.empirical = function(anno,features,sent,perm){
  
  # anno = data.table of genomic/gene features overlapping 450k array CG sites (generated by Genomic Ranges: findoverlaps)
  # features = vector of features for selecting columns in anno
  # sent = vector of sentinel 5mC sites
  # perm = matrix of permutations
  
  for(f in 1:length(features)){
    
    # makes matrix of features for selected features
    print(paste(features[f],": makes matrix of features for selected data column",sep=""))
    SS = anno[as.vector(t(perm)),features[f]]
    RM = matrix(SS,nrow(perm),ncol(perm),byrow=T)
    rownames(RM)=rownames(perm)
    
    # tabulate observed and expected proportions
    print(paste(features[f],": tabulate observed and expected proportions",sep=""))
    lev = mixedsort(levels(as.factor(RM)))
    obs = table(factor(anno[sent,features[f]],levels = lev))
    prop = t(rbind(prop.table(obs),prop.table(table(factor(RM[sent,],levels = lev)))))
    colnames(prop) = c("obs_prop","exp_prop")
    
    # generate expected counts
    print(paste(features[f],": generate expected counts",sep=""))
    rm = RM[sent,]
    for(p in 1:ncol(rm)){
      ex = table(factor(rm[,p],levels = lev))
      if(p==1){exp = ex}
      if(p>1){exp = rbind(exp,ex)}
    }
    rownames(exp)=paste("P",1:1000,sep="")  
    
    # analyse enrichment
    print(paste(features[f],": analyse enrichment",sep=""))
    for(e in 1:length(obs)){
      
      n1 = sum(exp[,e]>=obs[e]) # right tail
      n2 = sum(exp[,e]<=obs[e]) # left tail
      pE = ifelse(n1<n2,n1/1001*2,n2/1001*2)
      
      mean = mean(exp[,e])
      dev = sd(exp[,e])
      quant = quantile(exp[,e])
      fold = obs[e]/mean(exp[,e])
      logfold = log2(fold)
      
      res = c(fold,logfold,pE,obs[e],mean,dev,quant[c(3,2,4)])
      if(e==1) {allres = res}
      if(e>1) {allres = rbind(allres,res)}
    }
    rownames(allres)=colnames(exp)
    colnames(allres)=c("Fold","Log2fold","P_emp","Obs","MeanExp","SdExp","MedianExp","Q1Exp","Q3Exp")
    allres = cbind(allres,prop)
    print(allres)
    
    if(f==1){enrich = list(allres)}
    if(f>1){enrich = c(enrich,list(allres))}
  }
  
  names(enrich) = features
  return(enrich)
  
}

# example

roadmap_enrichment = ENRICH.empirical(roadmap_anno,"E063_adipocytes",sentinels, matches)
  
### 2. Enrichment analysis function: fishers

ENRICH.FI = function(anno,features,sent,perm){
  
  # anno = data.table of genomic/gene features overlapping 450k array CG sites (generated by Genomic Ranges: findoverlaps)
  # features = vector of features for selecting columns in anno
  # sent = vector of sentinel 5mC sites
  # perm = matrix of permutations ordered by sentinel, with sentinel as row name
  
  for(f in 1:length(features)){
    
    # select unique permutations
    uniquePerm = unique(unlist(perm[sent,]))
    
    # tabulate observed and expected numbers
    print(paste(features[f],": tabulate observed and expected numbers",sep=""))
    lev = mixedsort(levels(as.factor(anno[,features[f]])))
    obs = table(factor(anno[sent,features[f]],levels = lev))
    exp = table(factor(anno[uniquePerm,features[f]],levels=lev))
    
    freq = rbind(obs,exp)
    prop = rbind(prop.table(obs),prop.table(exp)); rownames(prop)=c("obs_prop","exp_prop")
    for(s in 1:ncol(freq)){
      
      obsFreq = freq[1,s]; expFreq = freq[2,s]
      obsOther = sum(freq[1,])-obsFreq; expOther = sum(freq[2,])-expFreq
      tab = matrix(c(obsFreq,expFreq,obsOther,expOther),nrow = 2)
      pval=fisher.test(tab,alternative = "two.sided")$p.value
      if(s==1) {fisher.p = pval}
      if(s>1) {fisher.p = c(fisher.p,pval)}
    }
    enr = rbind(freq,prop)
    enr = rbind(enr,fisher.p)
    qval = p.adjust(fisher.p,method="fdr",n=length(fisher.p))
    enr = rbind(enr,qval)
    
    # tabulate results 
    
    for(c in 1:ncol(enr)){
      fold = enr[3,c]/enr[4,c]
      res = c(enr[1,c],enr[2,c],enr[3,c],enr[4,c],fold,enr[5,c],enr[6,c])
      if(c==1) {allres = res}
      if(c>1) {allres = rbind(allres,res)}
    }
    
    rownames(allres)=colnames(enr)
    colnames(allres)=c("obs_frequency","exp_frequency","obs_proportion","exp_proportion","fold","p_fisher_2tail","q_fisher_2tail")
    #allres = t(allres)
    print(allres)
    
    if(f==1){enrich = list(allres)}
    if(f>1){enrich = c(enrich,list(allres))}
  }
  names(enrich) = features
  return(enrich)
  
}

roadmap_enrichment = ENRICH.FI(roadmap_anno,"E063_adipocytes",sentinels, matches)
